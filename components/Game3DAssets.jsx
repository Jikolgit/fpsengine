/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 ./public/model.glb 
*/
// FILE CONTAINING ALL THE 3D ASSET ON THE GAME
import * as THREE from 'three'
import React, { useContext, useEffect, useMemo, useRef } from 'react'
import { Point, Points, useGLTF, useTexture } from '@react-three/drei'
import { useFrame } from '@react-three/fiber';
import { appContext } from '../src/App';
import { mobContext } from './mob_2';
import { gameAppContext } from './GameApp';
import { CustomCounter } from './utils';


function prepareTexture(texture)
{
  const _texture = useTexture(texture);
  _texture.flipY = false;
  _texture.colorSpace = THREE.SRGBColorSpace; 
  _texture.minFilter = THREE.LinearFilter;
  _texture.magFilter = THREE.LinearFilter;

  return _texture;
}
export function GroundModel(props) {
  // 3D ASSET OF THE GROUND
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = prepareTexture('groundtxt.jpg');
 
  let mat = new THREE.MeshBasicMaterial({map:_texture,wireframe:_appContext.devMode.current? true : false});
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.dground.geometry} material={mat} />
    </group>
  )
}
export function SpearModelOnMap(props) {
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let passedTime = 0 ;
  let modelRef = useRef(null)
  let _texture = prepareTexture('gametexture.jpg');
  let mat = new THREE.MeshBasicMaterial({map:_texture,visible:props._visible,wireframe:_appContext.devMode.current? true : false});
  let visibleStatut;

  useFrame(()=>
    {
      if(!_appContext.gamePause.current)
      {
        passedTime += 1/40;
        modelRef.current.position.y += Math.sin(passedTime)/400;
        modelRef.current.rotation.y += (0.1/4);
      }
      
    })
  return (
      <>
      <mesh ref={modelRef}
            rotation={[0,0,Math.PI*0.1]} 
            geometry={nodes.spear_1.geometry} material={mat} position={[props.posX,props.posY,props.posZ]} />
      <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'red'} _speed={1} _number={30} x={props.posX} z={props.posZ} />
      </>
      
  )
}
export function SpearModel(props) {
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let modelRef = useRef(null)
  let _texture = prepareTexture('gametexture.jpg');

  let mat = new THREE.MeshBasicMaterial({map:_texture,visible:props._visible,wireframe:_appContext.devMode.current? true : false});
  
  let visibleStatut;
  return (
      <>
      <mesh ref={modelRef}
            rotation={[Math.PI*0.5,0,0]} 
            geometry={nodes.spear_1.geometry} material={mat} position={[props.posX,props.posY,props.posZ]} />
      </>
      
  )
}
export function PlayerCursor(props)
{
  return(<sprite 
          position={[props.x,props.y+0.05,props.z]} scale={0.015}
        >
          <spriteMaterial rotation={Math.PI*0.25} color={'white'}   />
          
        </sprite>
  )
}
export function Dummy_1_model(props) {
  let _mobContext = useContext(mobContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _appContext = useContext(appContext)
  let _texture = prepareTexture('gametexture.jpg');

  let modelRef = useRef(null);
  let mobHitManager = {startEffect:false,timer:10,effectCount:0}
  let mat = new THREE.MeshBasicMaterial({map:_texture});
  let visibleStatut;

  useFrame((clock)=>
    {
      if(!_appContext.gamePause.current)
      {
        modelRef.current.rotation.y += (1/250);
        
        if(mobHitManager.startEffect)
        {
          mobHitManager.timer--;
          if(mobHitManager.timer == 0)
          {
            mobHitManager.effectCount ++;
            mobHitManager.timer = 10;
            
            if(mobHitManager.effectCount<7)
            {
              modelRef.current.children[0].visible = modelRef.current.children[0].visible? false : true;
            }
            else
            {
              mobHitManager.effectCount = 0;
              mobHitManager.startEffect = false;
              modelRef.current.children[0].visible = false;
            }
            
          }
        }
      }
      
    })
  useEffect(()=>
    {
      _mobContext.enemyFunc.current = (args)=>
        {
          if(args == 'REMOVE-MOB')
          {
            modelRef.current.material.visible = false;
          }
          else if(args == 'MOB-TOUCHED')
          {
            modelRef.current.children[0].visible = false;
            mobHitManager = {startEffect:false,timer:10,effectCount:0}
            mobHitManager.startEffect = true
          }
        }
    },[])
  return (

    <mesh ref={modelRef} geometry={nodes.dummy_1.geometry} material={mat} position={[props.x,0.1,props.z]}>
          <mesh geometry={nodes.dummy_1.geometry} visible={false} scale={1}>
              <meshBasicMaterial color={'red'}  />
          </mesh>
    </mesh>
            
      
  )
}
export function TreeDecor_model(props) {
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = prepareTexture('texture1.jpg');
  let mat = new THREE.MeshBasicMaterial({map:_texture});


  return (

    <mesh  geometry={nodes.tree.geometry} material={mat} position={[props.x,0,props.z]} />
            
      
  )
}
export function WallModel(props)
{
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = prepareTexture('gametexture.jpg');
  let mat = new THREE.MeshBasicMaterial({map:_texture});
  return(
    <mesh geometry={nodes.wall_1.geometry} material={mat} position={[props.x,0,props.z]} />
  )
}
export function ItemType2Model(props) {
   //GERE LES ITEMS 3D SUR LA MAP Y COMPRIS LES ITEMS QUE LES MOBS
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let textureSrc;
  if(props.skin == 'wall_1'){textureSrc = 'gametexture.jpg'}
  else{textureSrc = 'texture2.jpg'}
  let _texture = prepareTexture(textureSrc);
  let itemRef = useRef(null);
  let itemGroupRef = useRef(null)
  let containerMat = new THREE.MeshBasicMaterial({visible:false});
  let mat = new THREE.MeshBasicMaterial({map:_texture,visible:true});
  
  useFrame((clock)=>
  {
    if(!_appContext.gamePause.current)
    {
      if(props.skin == 'heal_item_1')
      {
        itemRef.current.rotation.y += (1/30);
      }
      
    }
    
  })
  useEffect(()=>
    { 
      props.controller.itemController.value[props.controller.index] = (args)=>
      {
          if(args == 'SHOW-ITEM')
          {
            itemGroupRef.current.visible = true;
          }
          else if(args == 'REMOVE-ITEM')
          {
            itemGroupRef.current.visible = false;
          }
      } 
    },[])
  
  return (
      <>
      <group
            ref={itemGroupRef}
      >
          {props.skin == "heal_item_1" && <mesh ref={itemRef}  geometry={nodes.healthBox.geometry} material={containerMat} position={[props.x,0.1,props.z]}>
          <mesh geometry={nodes.health_1.geometry} material={mat} position={[-0.004, 0.5, 0.043]} rotation={[0.585, 0, 0]} />
            
          </mesh>}
          {props.skin == "heal_item_1" && <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'green'} _speed={1} _number={30} x={props.x} z={props.z} />}
          {props.skin == "spear" && 
                      <mesh
                          position={[props.x,0.5,props.z]}
                      >
                          <boxGeometry args={[1,0.5]} />

                          <meshBasicMaterial color={'blue'} visible={false} />
                          <SpearModelOnMap _visible={true} posX={0} posY={0} posZ={0} />
                          
                      </mesh>
            }
          {props.skin == "wall_1" && <mesh ref={itemRef}  geometry={nodes.wall_1.geometry} material={mat} position={[props.x,0,props.z]}/>}
      </group>
      
      </>
            
      
  )
}

export function ItemType1Model(props)
{
  //GERE LES UTEMS SPRITE SUR LA MAP Y COMPRIS LES ITEMS QUE LES MOBS
  let _appContext = useContext(appContext)
  let paticleTexture;
  let spriteRef = useRef(null);
  let passedTime = 0;

  if(props.skin == 'cauris_item')
  {
    paticleTexture = useTexture('caurisTXT.png');
  }
  useEffect(()=>
    { 
      props.controller.itemController.value[props.controller.index] = (args)=>
      {
          if(args == 'SHOW-ITEM')
          {
              spriteRef.current.visible = true;
          }
          else if(args == 'REMOVE-ITEM')
          {
              spriteRef.current.visible = false;
          }
      } 
    },[])
  useFrame((clock)=>
    {
        if(!_appContext.gamePause.current)
        {passedTime += 1/40;
        spriteRef.current.children[0].position.y += Math.sin(passedTime)/400;}
    })
  return(     <>
              <group ref={spriteRef} visible={props._visible} >
                    <sprite 
                      position={[props.x,0.5,props.z]} scale={[0.3,0.4,1]}
                    >
                      <spriteMaterial map={paticleTexture}   />
                      
                    </sprite>
                    <CustomParticle _skin={'star_07.png'} _size={0.5} _color={'white'}  _speed={1} _number={15} x={props.x} z={props.z} />
              </group>
              </>
  )
}
function CustomParticle(props)
{
  let _appContext = useContext(appContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let paticleTexture = useTexture(`particleRes/${props._skin}`);
  let objRef = useRef(null);
  let pointRef = useRef(null)
  let particlesContainer =[];
  let particlesInfo = [];

      for(let i =0;i<props._number;i++)
      {
        particlesInfo[i] = {start:false,timer:Math.floor(Math.random()*80),limit:1.1}
        particlesInfo[i].start = particlesInfo[i].timer ==0? true : false
        particlesContainer[i] = <sprite key={i} 
                                  position={[(Math.random()*0.9)-0.5
                                    ,0
                                    ,(Math.random()*0.9)-0.5]} scale={Math.random()*props._size}
                                >
                                  <spriteMaterial visible={false} color={props._color} alphaMap={paticleTexture} depthWrite={true}  />
                                </sprite>
      }  
  
  useFrame(()=>
    { 
      if(!_appContext.gamePause.current)
      
      {
          for(let i =0;i<pointRef.current.children.length;i++)
          {
            if(particlesInfo[i].start)
            {
              pointRef.current.children[i].position.y += 0.01*props._speed;
              pointRef.current.children[i].material.visible = true
              if(pointRef.current.children[i].position.y >= particlesInfo[i].limit )
              {
                particlesInfo[i].start = false;
                particlesInfo[i].timer = Math.floor(Math.random()*80);
                let scaleValue = Math.random()*props._size
                pointRef.current.children[i].scale.set(scaleValue,scaleValue,scaleValue)
                pointRef.current.children[i].material.visible = false;
                pointRef.current.children[i].position.y = 0;
              }
              // console.log(pointRef.current.children[i].position.y)
            }
            else
            {
              particlesInfo[i].timer --;
              if(particlesInfo[i].timer<=0)
              {
                particlesInfo[i].start = true;
              }
            }
            // pointRef.current.children[i].material.rotation += 0.01;
          }
      }
      
    })
  return(
        <group
          name='PARTICLE GROUP CONTAINER'
          position={[props.x,0.2,props.z]}
          ref={pointRef}
        >
            {particlesContainer}
        </group>
  )
}

export function ExitDoor_model(props)
{
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = useTexture('texture1.jpg');
  _texture.flipY = false;
  _texture.colorSpace = THREE.SRGBColorSpace; 
  _texture.minFilter = THREE.LinearFilter;
  _texture.magFilter = THREE.LinearFilter;
  let mat = new THREE.MeshBasicMaterial({map:_texture});
  let visibleStatut;
  let passedTime = 0;


  return(
    <mesh geometry={nodes.exitDoor.geometry} material={mat} position={[props.x, 0,props.z]} />
  )
}
export function Mob_1_model(props) {
  let _appContext = useContext(appContext);
  let _mobContext = useContext(mobContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = useTexture('gametexture.jpg');
  _texture.flipY = false;
  _texture.colorSpace = THREE.SRGBColorSpace; 
  _texture.minFilter = THREE.LinearFilter;
  _texture.magFilter = THREE.LinearFilter;
  let mat = new THREE.MeshBasicMaterial({map:_texture});
  let modelRef = useRef(null);
  let mobHitManager = {startEffect:false,timer:10,effectCount:0}
  let visibleStatut;
  let passedTime = 0;

  useFrame(()=>
    {
      if(!_appContext.gamePause.current)
      { passedTime += 1/40;
        modelRef.current.position.y += Math.sin(passedTime)/400;

        if(mobHitManager.startEffect)
          {
            mobHitManager.timer--;
            if(mobHitManager.timer == 0)
            {
              mobHitManager.effectCount ++;
              mobHitManager.timer = 10;
              
              if(mobHitManager.effectCount<7)
              { 
                modelRef.current.children[0].visible = modelRef.current.children[0].visible? false : true;
              }
              else
              {
                mobHitManager.effectCount = 0;
                mobHitManager.startEffect = false;
                modelRef.current.children[0].visible = false;
              }
              
            }
          }
      }
    })
  useEffect(()=>
    {
      _mobContext.enemyFunc.current = (args)=>
        {
          if(args == 'REMOVE-MOB')
          {
            modelRef.current.material.visible = false;
          }
          else if(args == 'MOB-TOUCHED')
          {
            modelRef.current.children[0].visible = false;
            mobHitManager = {startEffect:false,timer:10,effectCount:0}
            mobHitManager.startEffect = true
          }
        }
    },[])
  return (

        
          <mesh ref={modelRef} geometry={nodes.mob_1.geometry} material={mat} position={[props.x,0.1,props.z]} rotation={[-Math.PI, 0, -Math.PI]}>
                <mesh geometry={nodes.mob_1.geometry} visible={false} scale={1}>
                    <meshBasicMaterial color={'red'}  />
               </mesh>
          </mesh>
            
      
  )
}
export function Barier_Model(props)
{
  let _gameAppContext = useContext(gameAppContext)
  const { nodes, materials } = useGLTF('/model.glb');
  let _texture = useTexture('texture1.jpg');
  _texture.flipY = false;
  _texture.colorSpace = THREE.SRGBColorSpace; 
  _texture.minFilter = THREE.LinearFilter;
  _texture.magFilter = THREE.LinearFilter;
  let mat = new THREE.MeshBasicMaterial({map:_texture});
  let groupRef = useRef(null)
  let modelRef = useRef(null)
  let modelFunc = (args)=>
      {
          if(args == "hide")
          { 
            groupRef.current.visible = true;
            let customCounter = new CustomCounter(100,1,()=>
              {
                 modelRef.current.material.visible = false;
                 groupRef.current.visible = false;
              });
            
            customCounter.start();
            
          }
      }
  useEffect(()=>
    {
      if(props._for=='barier')
      {
        for(let i =0;i<_gameAppContext.barierModelIndexArr.value.length;i++)
          {
            if(_gameAppContext.barierModelIndexArr.value[i].objectId == props.refID)
            {
              _gameAppContext.barierModelIndexArr.value[i].ModelFunc = modelFunc;
            }
          }
      }
      
      else if(props._for=='exit')
      {
        // objectRef.current[exitDoorModelIndexArr.value[i].objectId].children[0].material.visible = false;
        
        for(let i =0;i<_gameAppContext.exitDoorModelIndexArr.value.length;i++)
          {
            if(_gameAppContext.exitDoorModelIndexArr.value[i].objectId == props.refID)
            {
              _gameAppContext.exitDoorModelIndexArr.value[i].modelFunc = modelFunc;
            }
          }
        
      }
      
    },[])
  return(     <>
              <mesh ref={modelRef} geometry={nodes.barier.geometry} scale={0.6} material={mat} position={[props.x,0,props.z]} rotation={[-Math.PI, 1.484, -Math.PI]} />
              <group
                    ref={groupRef}
                    visible={false}
              >
                  <CustomParticle _skin={'smoke_06.png'} _size={1.5} _color={'white'} _speed={3} _number={10} x={props.x} z={props.z} />
              </group>
              
              </>
  )
}
export function EnemyBullet(props)
{
  let bulletTXT = useTexture('ennemyBulletTxt.png');
  bulletTXT.flipY = false;
  bulletTXT.colorSpace = THREE.SRGBColorSpace; 
  bulletTXT.minFilter = THREE.LinearFilter;
  bulletTXT.magFilter = THREE.LinearFilter;

  return(
          <>
                   <mesh
                        key={props._i}
                        ref={props._ref}
                        position={props._position}
                    >
                        <sphereGeometry args={[0.2,10,10]} />
                        <meshBasicMaterial visible={false} map={bulletTXT} />
                    </mesh>
          </>
  )
}
useGLTF.preload('/model.glb')
